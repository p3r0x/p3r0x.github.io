[{"content":"ez_xor xor_revenge 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from Crypto.Util.number import * from secert import flag def han(b): return bin(b)[:2].count(\u0026#39;1\u0026#39;) p = getPrime(512) q = getPrime(512) r = getPrime(512) s = getPrime(512) N = p * q * s * r n = p * q gift = p ^ q gift1 = s \u0026amp; r gift2=s^r m=bytes_to_long(flag) c=pow(m,65537,N) print(f\u0026#39;N={N}\u0026#39;) print(f\u0026#39;n={n}\u0026#39;) print(f\u0026#39;c={c}\u0026#39;) print(f\u0026#39;gift={gift}\u0026#39;) print(f\u0026#39;gift1={gift1}\u0026#39;) print(f\u0026#39;gift2={gift2}\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 gift= p_xor=None q_xor=None def mask(k): return (1\u0026lt;\u0026lt;k)-1 bits=max(n.bit_length(), gift.bit_length()) + 1 def DFS(i,p_low,q_low): global p_xor, q_xor if i==bits: if p_low*q_low==n: p_xor=p_low q_xor=q_low return xi=(gift\u0026gt;\u0026gt;i) \u0026amp; 1 for pi in (0,1): qi=xi ^ pi p_new=p_low | (pi\u0026lt;\u0026lt;i) q_new=q_low | (qi\u0026lt;\u0026lt;i) k=i+1 mleft=(p_new*q_new) \u0026amp; mask(k) mright=n \u0026amp; mask(k) if mleft!=mright: continue DFS(i+1,p_new,q_new) if p_xor is not None: return DFS(0,0,0) p=p_xor q=q_xor print(p) print(q) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from Crypto.Util.number import isPrime \u0026#39;\u0026#39;\u0026#39; n=p*q gift2=p\u0026amp;q r hint=r\u0026amp;p \u0026#39;\u0026#39;\u0026#39; n= gift2= hint= r= cands=[1] for i in range(1,513): mod=1\u0026lt;\u0026lt;i mask=mod-1 new=set() for p0 in cands: for b in(0,1): p1=p0|(b\u0026lt;\u0026lt;(i-1)) try: inv=pow(p1,-1,mod) except ValueError: continue q1=(n*inv)%mod if(p1\u0026amp;q1)==(gift2\u0026amp;mask)and(r\u0026amp;p1)==(hint\u0026amp;mask): new.add(p1) cands=list(new) if not cands: raise Exception(f\u0026#34;无候选，出错于第{i}位\u0026#34;) for p in cands: if n%p==0: q=n//p print(p,q,p*q==n,(p\u0026amp;q)==gift2,(r\u0026amp;p)==hint,isPrime(p),isPrime(q)) break 打极客的时候用了非预期，复现一下预期解，\n低位p乘低位q应该等于低位的n，因为有p^ q,所以取p，然后另一个用p=p^ q ^ p,可以找到p和q\nxor_revenge的第二关，先取低位p通过q≡n·p⁻¹(mod 2^i)唯一确定低位q再结合p\u0026amp;q=gift2与r\u0026amp;p=hint最终还原出完整的pq\nez_LLL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from sage.all import * from Crypto.Util.number import * c1=3038112798633297184662383622304935743085885557233749158956007073849612482288376427868177129794650629723820320354956421200731057248206923390266126724749 c2=3067905676575976394191697470198775983424017171927789349465114051806662220809274519404690237600876120098160925189141020955735592394058043223836997390364 c3=161718305745223416862626464966392423773787018933651874103999525456915447775033958634175772362315345532256900450737279647892731432357809002698314267166 c4=28062790413629718933986669054186703589109523209003558087731275662743174344133808251212801549266309585389771008410013425648388045766331470112982955563124028892325281968496755965862457760066899153866340566596633175020232648844383549331469 M=matrix([[c1,c2,c3,-c4], [1,0,0,0], [0,1,0,0], [0,0,1,0],]).T W=diagonal_matrix([1,2**100,2**200,2**300]) M/=W M=M.dense_matrix().LLL() M*=W print(M[0]) p1=long_to_bytes(int(M[0][1])) p2=long_to_bytes(int(M[0][2])) p3=long_to_bytes(int(M[0][3])) flag=(p1+p2+p3).decode() print(flag) c4=c1x1+c2x2+c3*x3\n所以c1 * x1+c2 * x2+c3 * x3 -c4=0\nx1(c1,1,0,0)^T^+x2(c2,0,1,0)^t^+x3(c3,0,0,1)^T^+1*(-c4,0,0,0)^T^=(0,x1,x2,x3)\n$x_1 \\begin{pmatrix} c_1 \\ 1 \\ 0 \\ 0 \\end{pmatrix} + x_2 \\begin{pmatrix} c_2 \\ 0 \\ 1 \\ 0 \\end{pmatrix} + x_3 \\begin{pmatrix} c_3 \\ 0 \\ 0 \\ 1 \\end{pmatrix} + \\begin{pmatrix} -c_4 \\ 0 \\ 0 \\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\ x_1 \\ x_2 \\ x_3 \\end{pmatrix}$\n因为c1,c2,c3,c4很大，所以对1进行扩大加权\nez_lwe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from typing import Any from random import randint from Crypto.Util.number import bytes_to_long, getPrime from sage.all import GF, vector, random_vector, random_matrix from secret import flag M = bytes_to_long(flag) Key = 1 n, m = 48, 60 p = getPrime(64) L, R = 5900, 6000 e = vector([randint(L, R) for _ in range(m)]) s = random_vector(GF(p), n) A = random_matrix(GF(p), m, n) b = A * s + e S = [int(i) for i in s] for i in range(10): Key *= S[i] CC = int(M) ^ int(Key) print(f\u0026#34;b={list[Any](b)}\u0026#34;) print(f\u0026#34;A={[[int(x) for x in row] for row in A.rows()]}\u0026#34;) print(f\u0026#34;p={p}\u0026#34;) print(f\u0026#34;CC={CC}\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from sage.all import * from Crypto.Util.number import * b= A= p= CC= md=(5900+6000)//2 b=matrix(GF(p),b) A=matrix(GF(p),A) b=vector(ZZ,b.list()) b=vector([bi-md for bi in b ]) M=(Matrix(b).T.augment(A).augment(diagonal_matrix(60*[p])).T) M=M.LLL() for row in M: if (row!=0): row=[row1+md for row1 in row] print(row) break e=vector(row) b=vector([bi+md for bi in b]) C=b-e s=A.solve_right(C) S1=[int(i) for i in s] Key=prod(S1[i] for i in range(10)) M=int(Key)^CC print(long_to_bytes(M)) b = A * s + e mod（p）,可以写成，b=A * s+ e +k * p，所以-e=A * s-b+k * p，所以(-1,s,k)*(b,A,p)^T^=e，所以构造上面那个矩阵，\n令b’=b-md,所以 b=b’+md,所以 b’=e-md+A* smod(p)来把e减小。\nez_lcg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from Crypto.Util.number import * from sage.all import* S = (46147, 52452, 46661, 41313, 45329, 56710, 22716, 60048, 7531, 57956, 43635, 6865, 27649, 15280, 20963, 31871, 12088, 65368, 29612, 39641, 53837, 58597, 30620, 53443, 27963, 17687, 5191, 53831, 13115, 56927, 42723, 16589, 55206, 57677, 34314, 22949, 51886, 19471, 27427, 28514, 54538, 60595, 42958, 25021, 10867, 57037, 35767, 50850, 6847, 2927, 63781, 41308, 62381, 17164, 4673, 57568, 28371, 64296, 46780, 23692, 55183, 62120, 14601, 13632) A = (6672, 6350, 54616, 61915, 41606, 22475, 60337, 33513, 3313, 28909, 41958, 5962, 51820, 44248, 4065, 12634, 22740, 28634, 23512, 8821, 31862, 17372, 16090, 22034, 51226, 46284, 34399, 54981, 13952, 28952, 37330, 28217, 61185, 30089, 29461, 61627, 8862, 13953, 35361, 56259, 17576, 59751, 50416, 47356, 53008, 5502, 54239, 17120, 21370, 60413, 40762, 58038, 26013, 7577, 6174, 5516, 55742, 62684, 62690, 2616, 35700, 44473, 52409, 61782) b = 31406 p = 16227904979008897136248418192031314748505412380277026321741173198464052888603594501056875516599241959885632352910047386720881612381490986295441173263046508863568678875891863304142827241049053409505414701240071874394990874450228904184585460083532035618474206073202588430218751517767661890167793031564919805264830719544775969326937520389510119490226442672938411870362857201786663173905162389234501443225523670805044080971459 h = 7670249262620704753980815476762507729255066238739781136319625742011262177074795984359799744392590600821454300433620556061365270504441363584048417463022679854301647971713942799254621753907064538670727603259663836429995917326353557828885909543624262061400848266618171689398430292246770705845547238619257582056269515560485718447260793746703101618652712066827389461869550695598155696485234878222994565797487914488139538499340 c = 14429329882843202868007310856396559151286321017615769851023773970350550719937052360829994523971443476285582649472661288049559607031520496393719371721379721417612456366837213070725163130404745789492596362764953071192149548740423594536555742221304616367566933490759482789035561897713682847315817058003655924194630397363128653943091399075093769255229738173641889490913137440248912293179277610445400690535860920129097112605206 n1=64 p1=257 q1=0x10001 S1 = 49766128037688049554820940481512577374877082945061945368559257533763955716155048283594399996468577400153392858063758413824972309722341994134 S2 = 4403170647973657501812455423273579822085376510479535553996144698715186008446711898351057843985856064697053372523016176361594033620425527470135140395950572 S3 = 2280092490476650374559153036238968049212853871863099272082918173685177052127193137159631919327222697692351286157560120442811622767226016453440426345266868 S5 = 5953779515854306592437835145938391720619647350968976605123040510652967823934069354023960385825831707873106351516503464884756255789240813902048947132420142 delta=round(q1/p1) error_bound=int(floor((q1/p1)/2)) AS=sum(A[i]*S[i] for i in range(len(S)))%q1 x=(b-AS)%q1 if x\u0026gt;q1 // 2: x-=q1 m1=x%p1 S5=S5+m1 for e in range(1,1000): L=Matrix(ZZ,[[1,(2**e)*h], [0,(2**e)*p]]) f,g=L.LLL()[0] g=g//(2**e) try: S4=(f*c)%p%g*inverse(f,g)%g if(len(bin(S4))==513): print(S4) break except: pass Sx=[S1,S2,S3,S4,S5] t=[] for i in range(1,len(Sx)): t.append(Sx[i]-Sx[i-1]) T1=t[2]*t[0]-t[1]*t[1] T2=t[3]*t[1]-t[2]*t[2] m=gcd(T1,T2) S2_S1_inv=pow(S2-S1,-1,m) a=((S3-S2)*S2_S1_inv)%m b=(S2-a*S1)%m a_inv=pow(a,-1,m) seed=((S1-b)*a_inv)%m print(long_to_bytes(seed)) 首先解encrypt3:步骤和RSA那道差不多，\n1 2 3 4 5 6 7 delta=round(q1/p1) error_bound=int(floor((q1/p1)/2)) AS=sum(A[i]*S[i] for i in range(len(S)))%q1 x=(b-AS)%q1 if x\u0026gt;q1 // 2: x-=q1 m1=x%p1 解出m5后，解encrypt2:\n1 2 3 4 5 6 7 8 9 10 11 12 for e in range(1,1000): L=Matrix(ZZ,[[1,(2**e)*h], [0,(2**e)*p]]) f,g=L.LLL()[0] g=g//(2**e) try: S4=(f*c)%p%g*inverse(f,g)%g if(len(bin(S4))==513): print(S4) break except: pass sh+kp=c-msg\n$s\\begin{pmatrix}1\\2eh\\end{pmatrix}+k\\begin{pmatrix}0\\2ep\\end{pmatrix}=\\begin{pmatrix}s\\ 2e(sh+kp)\\end{pmatrix}$\n所以g=sh+kp=c-msg，f=s，因为c≡msg mod(g),f * c≡msg * f mod (g)，f^-1^ * f*c≡msg (mod g)相当于msg≡c(mod g)\u0026lt;f来消除误差\n然后解lcg:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Sx=[S1,S2,S3,S4,S5] t=[] for i in range(1,len(Sx)): t.append(Sx[i]-Sx[i-1]) T1=t[2]*t[0]-t[1]*t[1] T2=t[3]*t[1]-t[2]*t[2] m=gcd(T1,T2) S2_S1_inv=pow(S2-S1,-1,m) a=((S3-S2)*S2_S1_inv)%m b=(S2-a*S1)%m a_inv=pow(a,-1,m) seed=((S1-b)*a_inv)%m print(long_to_bytes(seed)) 令$t=s_{i}-s_{i-1}$，所以$t_{i}=(aS_{i-1}+b)-(aS_{i-2}+b)=a(S_{i-1}-S_{i-2})=a*t_{i-1}$,所以\n$$t_{n+1}t_{n-1}-t_n^2=a^2t_{n-1}^2-a^2t_{n-1}^2\\equiv0\\pmod{m}$$,所以可以求出m，然后ab很好求，求出来之后逆推算出seed\nRSA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from sage.all import * from Crypto.Util.number import* S= A = p_m= e = 65537 c_inner = n = Q = P = n1 = 64 p1 = 257 q1 = 65537 error_bound = int(floor((q1/p1)/2)) delta = int(round(q1/p1)) AS=sum(A[i]*S[i] for i in range(len(S)))%q1 x=(b-AS)%q1 if x\u0026gt;q1 // 2: x-=q1 lower=(x-error_bound)//delta upper=(x+error_bound)//delta for m in range(int(lower),int(upper)+1): if 0\u0026lt;=m\u0026lt;=p1: y=(AS+m*delta)%q1 error_condidate=(b-y)%q1 if error_condidate\u0026gt;q1/2: error_condidate-=q1 if -error_bound\u0026lt;=error_condidate\u0026lt;=error_bound: print(m) break e = 65537 p=p_m+m q=n//p c=(c_inner+AS) print(c) phi=(p-1)*(q-1) d=inverse(e,phi) m=pow(c,d,n) print(long_to_bytes(m)) 1 2 3 4 error_bound = int(floor((q1/p1)/2)) delta = int(round(q1/p1)) AS=sum(A[i]*S[i] for i in range(len(S)))%q1 x=(b-AS)%q1 算把已知数AS去掉，所以x=m * delta+error mod(q1)\n1 2 if x\u0026gt;q1 // 2: x-=q1 超过q1的一半就变为负数，保证在范围[-q1/2,q1/2]，因为模运算后x可能代表一个负数，需要把它调整到更接近零的位置，这样才符合实际值的范围\n比如-1%10=9，所以要转化\n1 2 lower=(x-error_bound)//delta upper=(x+error_bound)//delta m的范围，因为m=(x-e)//delta，因为x与m*delta的关系来找出m的可能范围,要保证x-delta的误差小于error_bound，所以通过这个公式算出m应该在哪个区间\n1 2 3 4 5 6 7 8 9 for m in range(int(lower),int(upper)+1): if 0\u0026lt;=m\u0026lt;=p1: y=(AS+m*delta)%q1 error_condidate=(b-y)%q1 if error_condidate\u0026gt;q1/2: error_condidate-=q1 if -error_bound\u0026lt;=error_condidate\u0026lt;=error_bound: print(m) break 遍历这个范围，然后用e是不是在误差的范围里面来验证\n","date":"2025-12-31T12:24:05+08:00","permalink":"https://p3r0x.github.io/p/test/","title":"Test"}]